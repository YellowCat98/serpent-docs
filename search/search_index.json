{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Serpent Docs Documentation for using the Serpent GD mod. (Serpent is in beta, if there are any bugs, you can report them by joining the Discord Server ) By using this mod, you acknowledge that the Developer is not responsible for any damage, data loss, or any harm done to your device that may occur as a result of executing malicious scripts, please do NOT execute scripts sent to you without first checking the source. to check whether a script is malicious or not, you may follow the following steps: open the zip file in WinRar, or just anything that lets you view zip files without unzipping, If this file doesn't have the two following files: \"script.json\" A .py (python) file. This means that the script does nothing at all, though it could be an another form of malicious. Do NOT put it in your Geometry dash's script folder, better safe than sorry. Delete the zip file and you do not need to follow the other steps as you have acknowledged that the \"script\" is most likely malicious. If it has a .py (python) file, and a script.json, and no other files. Unzip the zip file. Open the .py file in a text editor, notepad should work fine. Read the file does. Read what the file does, should be simple. If you acknowledged that the file is safe. you can safely execute the script, if it's not, then immediately delete any files related to the script. Including the zip file.","title":"Home"},{"location":"#serpent-docs","text":"Documentation for using the Serpent GD mod. (Serpent is in beta, if there are any bugs, you can report them by joining the Discord Server ) By using this mod, you acknowledge that the Developer is not responsible for any damage, data loss, or any harm done to your device that may occur as a result of executing malicious scripts, please do NOT execute scripts sent to you without first checking the source. to check whether a script is malicious or not, you may follow the following steps: open the zip file in WinRar, or just anything that lets you view zip files without unzipping, If this file doesn't have the two following files: \"script.json\" A .py (python) file. This means that the script does nothing at all, though it could be an another form of malicious. Do NOT put it in your Geometry dash's script folder, better safe than sorry. Delete the zip file and you do not need to follow the other steps as you have acknowledged that the \"script\" is most likely malicious. If it has a .py (python) file, and a script.json, and no other files. Unzip the zip file. Open the .py file in a text editor, notepad should work fine. Read the file does. Read what the file does, should be simple. If you acknowledged that the file is safe. you can safely execute the script, if it's not, then immediately delete any files related to the script. Including the zip file.","title":"Serpent Docs"},{"location":"getting-started/hooks/","text":"Hooks What is a hook? A hook is basically just a thing where you redirect a function call to another, a lot mods (not just GD mods!) rely on function hooking. How does Serpent handle function hooking? Serpent looks for a ClassName_FunctionName function within your script's class, if it exists, then it would hook ClassName::FunctionName (note that ClassName::FunctionName should be a function available to hook within Serpent and geode itself for the hook to be initialized!) Creating a simple hook Let's replace the MenuLayer's onMoreGames function! Steps: We define a function named MenuLayer_onMoreGames within our script's class. then pass self, this as the first two arguments, Serpent requires these two arguments so we'd be able to call the original if we need to (we will explain what an original is later.) Then we just pass whatever arguments MenuLayer_onMoreGames takes, in this case it's a single argument, it can have any name you want. Our function's signature is: MenuLayer_onMoreGames(self, this, sender) Code: class simplescript_yellowcat98: def __init__(self): self.script = script(\"simplescript_yellowcat98\", self) def MenuLayer_onMoreGames(self, this, sender): popup = FLAlertLayer.create(\"Popup Title\", \"This is the body of a popup.\", \"i think this is the button!\") # create a popup. popup.show() # show the popup to the screen! if __name__ == \"__main__\": simplescript_yellowcat98() Now you have hooked a function! Calling the Original What is the original in terms of function hooking? It's just the function you hooked, since all hooking does it just redirect function calls, the original in fact still exists and is callable! In Serpent, we take advantage of the this argument, this is of type MenuLayer, MenuLayer is a class which contains the original. Let's call the original in a MenuLayer_onQuit hook! (the onQuit function is the function that gets called when you press the X button in the main menu.) def MenuLayer_onQuit(self, this, sender): self.script.info(\"Before original!\") this.onQuit(sender) # Make sure to pass any required arguments! excluding `self, this` self.script.info(\"After original, btw this info function prints to the geode platform console because the regular print function doesnt show you the script's name!\")","title":"Hooks"},{"location":"getting-started/hooks/#hooks","text":"What is a hook? A hook is basically just a thing where you redirect a function call to another, a lot mods (not just GD mods!) rely on function hooking. How does Serpent handle function hooking? Serpent looks for a ClassName_FunctionName function within your script's class, if it exists, then it would hook ClassName::FunctionName (note that ClassName::FunctionName should be a function available to hook within Serpent and geode itself for the hook to be initialized!)","title":"Hooks"},{"location":"getting-started/hooks/#creating-a-simple-hook","text":"Let's replace the MenuLayer's onMoreGames function!","title":"Creating a simple hook"},{"location":"getting-started/hooks/#steps","text":"We define a function named MenuLayer_onMoreGames within our script's class. then pass self, this as the first two arguments, Serpent requires these two arguments so we'd be able to call the original if we need to (we will explain what an original is later.) Then we just pass whatever arguments MenuLayer_onMoreGames takes, in this case it's a single argument, it can have any name you want. Our function's signature is: MenuLayer_onMoreGames(self, this, sender)","title":"Steps:"},{"location":"getting-started/hooks/#code","text":"class simplescript_yellowcat98: def __init__(self): self.script = script(\"simplescript_yellowcat98\", self) def MenuLayer_onMoreGames(self, this, sender): popup = FLAlertLayer.create(\"Popup Title\", \"This is the body of a popup.\", \"i think this is the button!\") # create a popup. popup.show() # show the popup to the screen! if __name__ == \"__main__\": simplescript_yellowcat98() Now you have hooked a function!","title":"Code:"},{"location":"getting-started/hooks/#calling-the-original","text":"What is the original in terms of function hooking? It's just the function you hooked, since all hooking does it just redirect function calls, the original in fact still exists and is callable! In Serpent, we take advantage of the this argument, this is of type MenuLayer, MenuLayer is a class which contains the original. Let's call the original in a MenuLayer_onQuit hook! (the onQuit function is the function that gets called when you press the X button in the main menu.) def MenuLayer_onQuit(self, this, sender): self.script.info(\"Before original!\") this.onQuit(sender) # Make sure to pass any required arguments! excluding `self, this` self.script.info(\"After original, btw this info function prints to the geode platform console because the regular print function doesnt show you the script's name!\")","title":"Calling the Original"},{"location":"getting-started/init-empty-script/","text":"Initializing a script In order to create a script, create a folder, this can be anywhere! inside this folder, there'll be two files. script.json : This is a json file which includes mod metadata, this is the required syntax for it: // (this is only in jsonc for explaining what each key does, note that your script.json must not have comments! (i think it should work fine though)) { \"serpent\": \"1.0.0\", // This is the version of Serpent that the script is made for. \"name\": \"Simple Script\", // This is the name for the script \"id\": \"simplescript_yellowcat98\", // This is the ID of the script to avoid collision between other scripts! \"developer\": \"YellowCat98\" // The developer of the script! } mod_id.py : This is the main script! note that it is required for it to have the same name as the ID otherwise it won't execute! (check the Script syntax section ) Now that it's been set up, you're ready to start coding!","title":"Initializing an empty script"},{"location":"getting-started/init-empty-script/#initializing-a-script","text":"In order to create a script, create a folder, this can be anywhere! inside this folder, there'll be two files. script.json : This is a json file which includes mod metadata, this is the required syntax for it: // (this is only in jsonc for explaining what each key does, note that your script.json must not have comments! (i think it should work fine though)) { \"serpent\": \"1.0.0\", // This is the version of Serpent that the script is made for. \"name\": \"Simple Script\", // This is the name for the script \"id\": \"simplescript_yellowcat98\", // This is the ID of the script to avoid collision between other scripts! \"developer\": \"YellowCat98\" // The developer of the script! } mod_id.py : This is the main script! note that it is required for it to have the same name as the ID otherwise it won't execute! (check the Script syntax section ) Now that it's been set up, you're ready to start coding!","title":"Initializing a script"},{"location":"getting-started/prerequisities/","text":"Prerequisities Before making mods, you need to first have some stuff installed, Which are: Geometry Dash: Serpent is a Geometry Dash mod. so you obviously would need the game you're trying to modify! Geode: Serpent is a mod powered using Geode SDK, you can get geode from https://geode-sdk.org! Serpent: In order to installed Serpent, you have to go into Geode and then you can download the latest version of Serpent, though as of 11/12/2024, Serpent is yet to be finished! so you'd have to get it from github for now. Python: To keep Serpent's size manageable, you need to have python itself installed on your device, you can get python from https://python.org. If you got all of these installed, you're ready to continue!","title":"Prerequisities"},{"location":"getting-started/prerequisities/#prerequisities","text":"Before making mods, you need to first have some stuff installed, Which are: Geometry Dash: Serpent is a Geometry Dash mod. so you obviously would need the game you're trying to modify! Geode: Serpent is a mod powered using Geode SDK, you can get geode from https://geode-sdk.org! Serpent: In order to installed Serpent, you have to go into Geode and then you can download the latest version of Serpent, though as of 11/12/2024, Serpent is yet to be finished! so you'd have to get it from github for now. Python: To keep Serpent's size manageable, you need to have python itself installed on your device, you can get python from https://python.org. If you got all of these installed, you're ready to continue!","title":"Prerequisities"},{"location":"getting-started/syntax/","text":"Script syntax Your script is required to have a class (in which you guessed must have the same name as the ID!!) Each class must have an instance of the built-in class script , which its constructor takes two arguments, which are: ID: the ID of your script! mainClass: your script's class. Syntax example: # Serpent binds all geode and cocos functions/classes into __main__, you do not need to import any modules. class simplescript_yellowcat98: def __init__(self): self.script = script(\"simplescript_yellowcat98\", self) if __name__ == \"__main__\": simplescript_yellowcat98() # Initailze an instance of simplescript_yellowcat98, this will be executed on startup. Now we have a script that does NOTHING! What can you do with it? nothing basically because uhh it does nothing other than initialize a new script, it should execute if it's enabled though. Now all that's left is to package it into a .zip file, the .zip file MUST have the same filename as the ID.","title":"Script Syntax"},{"location":"getting-started/syntax/#script-syntax","text":"Your script is required to have a class (in which you guessed must have the same name as the ID!!) Each class must have an instance of the built-in class script , which its constructor takes two arguments, which are: ID: the ID of your script! mainClass: your script's class. Syntax example: # Serpent binds all geode and cocos functions/classes into __main__, you do not need to import any modules. class simplescript_yellowcat98: def __init__(self): self.script = script(\"simplescript_yellowcat98\", self) if __name__ == \"__main__\": simplescript_yellowcat98() # Initailze an instance of simplescript_yellowcat98, this will be executed on startup. Now we have a script that does NOTHING! What can you do with it? nothing basically because uhh it does nothing other than initialize a new script, it should execute if it's enabled though. Now all that's left is to package it into a .zip file, the .zip file MUST have the same filename as the ID.","title":"Script syntax"},{"location":"tutorials/printing/","text":"Printing to the console Normally you'd think of just using print from Python's standard library. But that makes a direct call to stdout, making it impossible to tell which mod is printing. Serpent introduces script.info , script.debug , script.warn and script.error , which you can use the same exact way, here's an example sigma = False def MenuLayer_init(self, this): if not sigma: self.script.error(\"You are not sigma.\") else: self.script.info(\"You are sigma!\") **Remember that using input does not work at all, at it makes a call to stdin and geode restricts stdin calls, it only allows stdout.","title":"Printing to the console"},{"location":"tutorials/printing/#printing-to-the-console","text":"Normally you'd think of just using print from Python's standard library. But that makes a direct call to stdout, making it impossible to tell which mod is printing. Serpent introduces script.info , script.debug , script.warn and script.error , which you can use the same exact way, here's an example sigma = False def MenuLayer_init(self, this): if not sigma: self.script.error(\"You are not sigma.\") else: self.script.info(\"You are sigma!\") **Remember that using input does not work at all, at it makes a call to stdin and geode restricts stdin calls, it only allows stdout.","title":"Printing to the console"},{"location":"tutorials/sprites/","text":"Sprites Sprites in Serpent are called CCSprite, in order to create a CCSprite, we call the static method CCSprite.create() , which takes a single argument and returns a CCSprite. CCSprite is a CCNode, so we can add it as a child node to other nodes! Example: def MenuLayer_init(self, this): if not this.init(): return False winSize = CCDirector.get().getWinSize() sprite = CCSprite.create(\"<spriteName>.png\") # Remember, this doesn't get sprites from spritesheets, we need a different method for that! sprite.setPosition(CCPoint(winSize.width / 2, winSize.height / 2)) # Place the sprite in the middle of the screen. return True Sprites from Spritesheets It's pretty simple, instead of calling the static method CCSprite.create we call CCSprite.createWithSpriteFrameName , here's an example! ```python def MenuLayer_init(self, this): if not this.init(): return False sprite = CCSprite.create(\"GJ_arrow_01_001.png\") # GJ_arrow_01_001.png is a sprite from the GJ_gamesheet_03.png spritesheet, though it does not matter! return True","title":"Sprites"},{"location":"tutorials/sprites/#sprites","text":"Sprites in Serpent are called CCSprite, in order to create a CCSprite, we call the static method CCSprite.create() , which takes a single argument and returns a CCSprite. CCSprite is a CCNode, so we can add it as a child node to other nodes! Example: def MenuLayer_init(self, this): if not this.init(): return False winSize = CCDirector.get().getWinSize() sprite = CCSprite.create(\"<spriteName>.png\") # Remember, this doesn't get sprites from spritesheets, we need a different method for that! sprite.setPosition(CCPoint(winSize.width / 2, winSize.height / 2)) # Place the sprite in the middle of the screen. return True","title":"Sprites"},{"location":"tutorials/sprites/#sprites-from-spritesheets","text":"It's pretty simple, instead of calling the static method CCSprite.create we call CCSprite.createWithSpriteFrameName , here's an example! ```python def MenuLayer_init(self, this): if not this.init(): return False sprite = CCSprite.create(\"GJ_arrow_01_001.png\") # GJ_arrow_01_001.png is a sprite from the GJ_gamesheet_03.png spritesheet, though it does not matter! return True","title":"Sprites from Spritesheets"},{"location":"tutorials/ui-elements/","text":"UI Elements To do anything UI related, you will have to hook the MenuLayer_init function. as it is reponsible for UI elements. Lets try adding a label to the main menu! def MenuLayer_init(self, this): if not this.init(): return False # Make sure to call original (otherwise the UI will be BLACK.) label = CCLabelBMFont.create(\"Hello, World!\", \"bigFont.fnt\") this.addChild(label) return True Now we have a label that says \"Hello, World!\", though the label is placed in the bottom corner, to fix this, we have to do some positioning! def MenuLayer_init(self, this): if not this.init(): return False label = CCLabelBMFont.create(\"Hello, World!\", \"bigFont.fnt\") label.setPosition(CCPoint(6, 9)) # This moves the label to X position 6, and Y position 9. this.addChild(label) return True Node IDs Geode has a little feature added into cocos2d, which is Node IDS! What is a Node ID? its a string, which is linked to a UI element, some nodes don't have Node IDs though, to check, it is recommended to install the Dev Tools mod. Getting a child node through a Node ID We use the CCNode.getChildByID function, what is a CCNode? its just everything you see on the screen, under the hood, everything derives from CCNode. Example: def MenuLayer_init(self, this): if not this.init(): return False menu = this.getChildByID(\"bottom-menu\") # This retrieves a CCMenu of ID bottom-menu. # Do something with `menu` return True","title":"UI Elements"},{"location":"tutorials/ui-elements/#ui-elements","text":"To do anything UI related, you will have to hook the MenuLayer_init function. as it is reponsible for UI elements. Lets try adding a label to the main menu! def MenuLayer_init(self, this): if not this.init(): return False # Make sure to call original (otherwise the UI will be BLACK.) label = CCLabelBMFont.create(\"Hello, World!\", \"bigFont.fnt\") this.addChild(label) return True Now we have a label that says \"Hello, World!\", though the label is placed in the bottom corner, to fix this, we have to do some positioning! def MenuLayer_init(self, this): if not this.init(): return False label = CCLabelBMFont.create(\"Hello, World!\", \"bigFont.fnt\") label.setPosition(CCPoint(6, 9)) # This moves the label to X position 6, and Y position 9. this.addChild(label) return True","title":"UI Elements"},{"location":"tutorials/ui-elements/#node-ids","text":"Geode has a little feature added into cocos2d, which is Node IDS! What is a Node ID? its a string, which is linked to a UI element, some nodes don't have Node IDs though, to check, it is recommended to install the Dev Tools mod.","title":"Node IDs"},{"location":"tutorials/ui-elements/#getting-a-child-node-through-a-node-id","text":"We use the CCNode.getChildByID function, what is a CCNode? its just everything you see on the screen, under the hood, everything derives from CCNode. Example: def MenuLayer_init(self, this): if not this.init(): return False menu = this.getChildByID(\"bottom-menu\") # This retrieves a CCMenu of ID bottom-menu. # Do something with `menu` return True","title":"Getting a child node through a Node ID"}]}